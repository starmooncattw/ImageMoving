<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>圖片動畫</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: transparent;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        #animatedImage {
            position: absolute;
            will-change: transform, filter, opacity;
            transform-style: preserve-3d;
        }
    </style>
</head>
<body>
    <img id="animatedImage" alt="animated">

    <script>
        // IndexedDB 讀取
        let db;
        const dbName = 'ImageAnimationDB';
        const storeName = 'config';

        const request = indexedDB.open(dbName, 1);
        request.onupgradeneeded = function(e) {
            db = e.target.result;
            if (!db.objectStoreNames.contains(storeName)) {
                db.createObjectStore(storeName);
            }
        };
        request.onsuccess = function(e) {
            db = e.target.result;
            loadConfig();
        };
        request.onerror = function(e) {
            console.error('IndexedDB error:', e);
            document.body.innerHTML = '<div style="color: #333; text-align: center; padding: 50px; font-size: 20px;">資料庫錯誤！</div>';
        };

        async function loadConfig() {
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get('imageAnimationConfig');

            request.onsuccess = function() {
                const config = request.result;
                if (!config) {
                    document.body.innerHTML = '<div style="color: #333; text-align: center; padding: 50px; font-size: 20px;">請先在 config.html 設定圖片！</div>';
                    return;
                }
                initAnimation(config);
            };

            request.onerror = function() {
                document.body.innerHTML = '<div style="color: #333; text-align: center; padding: 50px; font-size: 20px;">讀取設定失敗！</div>';
            };
        }

        function initAnimation(config) {
        const img = document.getElementById('animatedImage');

        // 設定圖片
        img.src = config.image;
        img.style.width = config.size + '%';
        img.style.opacity = config.opacity / 100;

        // 翻轉
        let flipTransform = '';
        if (config.flip === 'horizontal') flipTransform = 'scaleX(-1)';
        else if (config.flip === 'vertical') flipTransform = 'scaleY(-1)';
        else if (config.flip === 'both') flipTransform = 'scaleX(-1) scaleY(-1)';

        // 動態生成 CSS 動畫
        const styleSheet = document.createElement('style');
        let animations = [];
        let filters = [];

        // 移動動畫
        const movement = config.movement;
        const speed = 11 - movement.speed; // 反轉速度值
        const duration = speed + 's';

        // 位置設定
        const hPos = movement.horizontalPosition || 'middle';
        const vPos = movement.verticalPosition || 'center';

        const horizontalTop = {
            top: hPos === 'top' ? '0%' : (hPos === 'middle' ? '50%' : '100%'),
            transform: hPos === 'top' ? 'translateY(0%)' : (hPos === 'middle' ? 'translateY(-50%)' : 'translateY(-100%)')
        };

        const verticalLeft = {
            left: vPos === 'left' ? '0%' : (vPos === 'center' ? '50%' : '100%'),
            transform: vPos === 'left' ? 'translateX(0%)' : (vPos === 'center' ? 'translateX(-50%)' : 'translateX(-100%)')
        };

        let movementKeyframes = '';
        let animationName = 'move-' + movement.mode;

        switch(movement.mode) {
            case 'static':
                img.style.left = '50%';
                img.style.top = '50%';
                img.style.transform = 'translate(-50%, -50%) ' + flipTransform;
                break;

            case 'randomAppear':
                movementKeyframes = `@keyframes ${animationName} {
                    0%, 100% { opacity: 0; }
                    10%, 90% { opacity: ${config.opacity / 100}; }
                }`;
                animations.push(`${animationName} ${duration} infinite`);

                // 隨機位置
                setInterval(() => {
                    const x = Math.random() * (window.innerWidth - img.offsetWidth);
                    const y = Math.random() * (window.innerHeight - img.offsetHeight);
                    img.style.left = x + 'px';
                    img.style.top = y + 'px';
                }, speed * 1000);

                img.style.left = '50%';
                img.style.top = '50%';
                break;

            case 'randomBounce':
                let x = Math.random() * window.innerWidth;
                let y = Math.random() * window.innerHeight;
                let vx = (Math.random() - 0.5) * (11 - speed);
                let vy = (Math.random() - 0.5) * (11 - speed);

                function bounce() {
                    x += vx;
                    y += vy;

                    if (x <= 0 || x >= window.innerWidth - img.offsetWidth) vx = -vx;
                    if (y <= 0 || y >= window.innerHeight - img.offsetHeight) vy = -vy;

                    img.style.left = x + 'px';
                    img.style.top = y + 'px';
                    requestAnimationFrame(bounce);
                }
                bounce();
                break;

            case 'leftToRight':
                movementKeyframes = `@keyframes ${animationName} {
                    from { left: -10%; }
                    to { left: 110%; }
                }`;
                animations.push(`${animationName} ${duration} linear infinite`);
                img.style.top = horizontalTop.top;
                img.style.transform = horizontalTop.transform + ' ' + flipTransform;
                break;

            case 'rightToLeft':
                movementKeyframes = `@keyframes ${animationName} {
                    from { left: 110%; }
                    to { left: -10%; }
                }`;
                animations.push(`${animationName} ${duration} linear infinite`);
                img.style.top = horizontalTop.top;
                img.style.transform = horizontalTop.transform + ' ' + flipTransform;
                break;

            case 'horizontalLoop':
                const loopStart = movement.horizontalLoopStart || 'left';
                const hTransform = horizontalTop.transform;
                const flipY = config.flip === 'vertical' || config.flip === 'both' ? 'scaleY(-1)' : '';

                // 擴大範圍確保完全離開畫面
                let startPos = loopStart === 'left' ? -20 : 140;
                let endPos = loopStart === 'left' ? 140 : -20;

                // 先設定固定的垂直位置
                img.style.top = horizontalTop.top;
                img.style.left = startPos + '%';

                function horizontalLoopAnimate() {
                    const totalDuration = speed * 1000;
                    let currentFlip = 1;

                    function moveForward() {
                        // 使用 CSS transition 而非 animation
                        img.style.transition = 'none';
                        img.style.left = startPos + '%';
                        img.style.top = horizontalTop.top;
                        img.style.transform = `${hTransform} scaleX(${currentFlip}) ${flipY}`;

                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                img.style.transition = `left ${totalDuration}ms linear`;
                                img.style.left = endPos + '%';

                                setTimeout(() => {
                                    currentFlip = -1;
                                    img.style.transition = 'none';
                                    img.style.transform = `${hTransform} scaleX(${currentFlip}) ${flipY}`;
                                    setTimeout(moveBackward, 50);
                                }, totalDuration);
                            });
                        });
                    }

                    function moveBackward() {
                        img.style.transition = 'none';
                        img.style.left = endPos + '%';
                        img.style.top = horizontalTop.top;
                        img.style.transform = `${hTransform} scaleX(${currentFlip}) ${flipY}`;

                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                img.style.transition = `left ${totalDuration}ms linear`;
                                img.style.left = startPos + '%';

                                setTimeout(() => {
                                    currentFlip = 1;
                                    img.style.transition = 'none';
                                    img.style.transform = `${hTransform} scaleX(${currentFlip}) ${flipY}`;
                                    setTimeout(moveForward, 50);
                                }, totalDuration);
                            });
                        });
                    }

                    moveForward();
                }

                horizontalLoopAnimate();
                break;

            case 'topToBottom':
                movementKeyframes = `@keyframes ${animationName} {
                    from { top: -10%; }
                    to { top: 110%; }
                }`;
                animations.push(`${animationName} ${duration} linear infinite`);
                img.style.left = verticalLeft.left;
                img.style.transform = verticalLeft.transform + ' ' + flipTransform;
                break;

            case 'bottomToTop':
                movementKeyframes = `@keyframes ${animationName} {
                    from { top: 110%; }
                    to { top: -10%; }
                }`;
                animations.push(`${animationName} ${duration} linear infinite`);
                img.style.left = verticalLeft.left;
                img.style.transform = verticalLeft.transform + ' ' + flipTransform;
                break;

            case 'verticalLoop':
                const vLoopStart = movement.verticalLoopStart || 'top';
                const vTransform = verticalLeft.transform;
                const flipX = config.flip === 'horizontal' || config.flip === 'both' ? 'scaleX(-1)' : '';

                // 擴大範圍確保完全離開畫面
                let vStartPos = vLoopStart === 'top' ? -20 : 140;
                let vEndPos = vLoopStart === 'top' ? 140 : -20;

                // 先設定固定的水平位置
                img.style.left = verticalLeft.left;
                img.style.top = vStartPos + '%';

                function verticalLoopAnimate() {
                    const totalDuration = speed * 1000;
                    let currentFlipV = 1;

                    function moveDown() {
                        img.style.transition = 'none';
                        img.style.top = vStartPos + '%';
                        img.style.left = verticalLeft.left;
                        img.style.transform = `${vTransform} scaleY(${currentFlipV}) ${flipX}`;

                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                img.style.transition = `top ${totalDuration}ms linear`;
                                img.style.top = vEndPos + '%';

                                setTimeout(() => {
                                    currentFlipV = -1;
                                    img.style.transition = 'none';
                                    img.style.transform = `${vTransform} scaleY(${currentFlipV}) ${flipX}`;
                                    setTimeout(moveUp, 50);
                                }, totalDuration);
                            });
                        });
                    }

                    function moveUp() {
                        img.style.transition = 'none';
                        img.style.top = vEndPos + '%';
                        img.style.left = verticalLeft.left;
                        img.style.transform = `${vTransform} scaleY(${currentFlipV}) ${flipX}`;

                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                img.style.transition = `top ${totalDuration}ms linear`;
                                img.style.top = vStartPos + '%';

                                setTimeout(() => {
                                    currentFlipV = 1;
                                    img.style.transition = 'none';
                                    img.style.transform = `${vTransform} scaleY(${currentFlipV}) ${flipX}`;
                                    setTimeout(moveDown, 50);
                                }, totalDuration);
                            });
                        });
                    }

                    moveDown();
                }

                verticalLoopAnimate();
                break;

            case 'diagonalTLBR':
                movementKeyframes = `@keyframes ${animationName} {
                    from { left: -10%; top: -10%; }
                    to { left: 110%; top: 110%; }
                }`;
                animations.push(`${animationName} ${duration} linear infinite`);
                break;

            case 'diagonalTRBL':
                movementKeyframes = `@keyframes ${animationName} {
                    from { left: 110%; top: -10%; }
                    to { left: -10%; top: 110%; }
                }`;
                animations.push(`${animationName} ${duration} linear infinite`);
                break;

            case 'diagonalBLTR':
                movementKeyframes = `@keyframes ${animationName} {
                    from { left: -10%; top: 110%; }
                    to { left: 110%; top: -10%; }
                }`;
                animations.push(`${animationName} ${duration} linear infinite`);
                break;

            case 'diagonalBRTL':
                movementKeyframes = `@keyframes ${animationName} {
                    from { left: 110%; top: 110%; }
                    to { left: -10%; top: -10%; }
                }`;
                animations.push(`${animationName} ${duration} linear infinite`);
                break;

            case 'circle':
                const radius = movement.circleRadius || 200;
                const centerMode = movement.circleCenter || 'fixed';

                if (centerMode === 'fixed') {
                    // 固定中心
                    movementKeyframes = `@keyframes ${animationName} {
                        from { transform: translate(-50%, -50%) rotate(0deg) translateX(${radius}px) rotate(0deg) ${flipTransform}; }
                        to { transform: translate(-50%, -50%) rotate(360deg) translateX(${radius}px) rotate(-360deg) ${flipTransform}; }
                    }`;
                    animations.push(`${animationName} ${duration} linear infinite`);
                    img.style.left = '50%';
                    img.style.top = '50%';
                } else {
                    // 隨機移動中心
                    let centerX = 50;
                    let centerY = 50;
                    let angle = 0;

                    function randomCircleAnimate() {
                        const rotationDuration = speed * 1000;
                        const centerChangeDuration = 3000; // 中心每3秒變化

                        function rotateStep() {
                            angle += (360 / rotationDuration) * 16; // 假設60fps
                            if (angle >= 360) angle -= 360;

                            const rad = (angle * Math.PI) / 180;
                            const x = centerX + (radius / window.innerWidth * 100) * Math.cos(rad);
                            const y = centerY + (radius / window.innerHeight * 100) * Math.sin(rad);

                            img.style.left = x + '%';
                            img.style.top = y + '%';
                            img.style.transform = `translate(-50%, -50%) ${flipTransform}`;

                            requestAnimationFrame(rotateStep);
                        }

                        function changeCenter() {
                            centerX = 20 + Math.random() * 60; // 20% ~ 80%
                            centerY = 20 + Math.random() * 60;
                            setTimeout(changeCenter, centerChangeDuration);
                        }

                        rotateStep();
                        changeCenter();
                    }

                    randomCircleAnimate();
                }
                break;

            case 'zigzag':
                movementKeyframes = `@keyframes ${animationName} {
                    0% { left: -10%; top: 20%; }
                    25% { left: 30%; top: 80%; }
                    50% { left: 50%; top: 20%; }
                    75% { left: 80%; top: 80%; }
                    100% { left: 110%; top: 20%; }
                }`;
                animations.push(`${animationName} ${duration} linear infinite`);
                break;
        }

        if (movementKeyframes) styleSheet.textContent += movementKeyframes + '\n';

        // 特效動畫
        const effects = config.effects;

        // 旋轉
        if (effects.rotate.enabled) {
            const rotSpeed = 11 - effects.rotate.speed;
            let rotKeyframes = '';
            if (effects.rotate.mode === 'clockwise') {
                rotKeyframes = '@keyframes rotate-cw { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }';
                animations.push(`rotate-cw ${rotSpeed}s linear infinite`);
            } else if (effects.rotate.mode === 'counterclockwise') {
                rotKeyframes = '@keyframes rotate-ccw { from { transform: rotate(0deg); } to { transform: rotate(-360deg); } }';
                animations.push(`rotate-ccw ${rotSpeed}s linear infinite`);
            } else if (effects.rotate.mode === 'swing') {
                rotKeyframes = '@keyframes rotate-swing { 0%, 100% { transform: rotate(-30deg); } 50% { transform: rotate(30deg); } }';
                animations.push(`rotate-swing ${rotSpeed}s ease-in-out infinite`);
            }
            styleSheet.textContent += rotKeyframes + '\n';
        }

        // 縮放脈動
        if (effects.scale.enabled) {
            const scaleSpeed = 11 - effects.scale.speed || 3;
            const scaleRange = effects.scale.range;
            let scaleKeyframes = '';
            if (effects.scale.mode === 'pulse') {
                scaleKeyframes = `@keyframes scale-pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(${scaleRange}); } }`;
            } else {
                scaleKeyframes = `@keyframes scale-bounce { 0%, 100% { transform: scale(1); } 50% { transform: scale(${scaleRange}); } }`;
            }
            animations.push(`${effects.scale.mode === 'pulse' ? 'scale-pulse' : 'scale-bounce'} ${scaleSpeed}s ease-in-out infinite`);
            styleSheet.textContent += scaleKeyframes + '\n';
        }

        // 扭曲
        if (effects.skew.enabled) {
            const skewStr = effects.skew.strength;
            const skewKeyframes = effects.skew.direction === 'horizontal'
                ? `@keyframes skew-h { 0%, 100% { transform: skewX(-${skewStr}deg); } 50% { transform: skewX(${skewStr}deg); } }`
                : `@keyframes skew-v { 0%, 100% { transform: skewY(-${skewStr}deg); } 50% { transform: skewY(${skewStr}deg); } }`;
            animations.push(`${effects.skew.direction === 'horizontal' ? 'skew-h' : 'skew-v'} 3s ease-in-out infinite`);
            styleSheet.textContent += skewKeyframes + '\n';
        }

        // 傾斜搖晃
        if (effects.tilt.enabled) {
            const tiltAngle = effects.tilt.angle;
            const tiltKeyframes = effects.tilt.mode === 'swingLR'
                ? `@keyframes tilt-lr { 0%, 100% { transform: rotate(-${tiltAngle}deg); } 50% { transform: rotate(${tiltAngle}deg); } }`
                : `@keyframes tilt-ud { 0%, 100% { transform: rotateX(-${tiltAngle}deg); } 50% { transform: rotateX(${tiltAngle}deg); } }`;
            animations.push(`${effects.tilt.mode === 'swingLR' ? 'tilt-lr' : 'tilt-ud'} 2s ease-in-out infinite`);
            styleSheet.textContent += tiltKeyframes + '\n';
        }

        // 模糊
        if (effects.blur.enabled) {
            const blurStr = effects.blur.strength;
            if (effects.blur.type === 'gaussian') {
                filters.push(`blur(${blurStr}px)`);
            } else {
                const blurKeyframes = `@keyframes blur-motion { 0%, 100% { filter: blur(0px); } 50% { filter: blur(${blurStr}px); } }`;
                animations.push(`blur-motion 1s ease-in-out infinite`);
                styleSheet.textContent += blurKeyframes + '\n';
            }
        }

        // 陰影/發光
        if (effects.shadow.enabled) {
            const shadowStr = effects.shadow.strength;
            const shadowColor = effects.shadow.color;
            if (effects.shadow.type === 'drop') {
                filters.push(`drop-shadow(${shadowStr}px ${shadowStr}px ${shadowStr}px ${shadowColor})`);
            } else {
                filters.push(`drop-shadow(0 0 ${shadowStr}px ${shadowColor})`);
            }
        }

        // 色相旋轉
        if (effects.hueRotate.enabled) {
            const hueSpeed = 11 - effects.hueRotate.speed;
            const hueKeyframes = '@keyframes hue-rotate { from { filter: hue-rotate(0deg); } to { filter: hue-rotate(360deg); } }';
            animations.push(`hue-rotate ${hueSpeed}s linear infinite`);
            styleSheet.textContent += hueKeyframes + '\n';
        }

        // 3D旋轉
        if (effects.rotate3d.enabled) {
            const r3dSpeed = 11 - effects.rotate3d.speed;
            const axis = effects.rotate3d.axis.toUpperCase();
            const r3dKeyframes = `@keyframes rotate3d-${axis} { from { transform: rotate${axis}(0deg); } to { transform: rotate${axis}(360deg); } }`;
            animations.push(`rotate3d-${axis} ${r3dSpeed}s linear infinite`);
            styleSheet.textContent += r3dKeyframes + '\n';
        }

        // 抖動
        if (effects.shake.enabled) {
            const shakeStr = effects.shake.strength;
            const shakeKeyframes = `@keyframes shake {
                0%, 100% { transform: translate(0, 0); }
                10% { transform: translate(-${shakeStr}px, ${shakeStr}px); }
                20% { transform: translate(${shakeStr}px, -${shakeStr}px); }
                30% { transform: translate(-${shakeStr}px, -${shakeStr}px); }
                40% { transform: translate(${shakeStr}px, ${shakeStr}px); }
                50% { transform: translate(-${shakeStr}px, ${shakeStr}px); }
                60% { transform: translate(${shakeStr}px, -${shakeStr}px); }
                70% { transform: translate(-${shakeStr}px, -${shakeStr}px); }
                80% { transform: translate(${shakeStr}px, ${shakeStr}px); }
                90% { transform: translate(-${shakeStr}px, -${shakeStr}px); }
            }`;
            animations.push(`shake 0.5s infinite`);
            styleSheet.textContent += shakeKeyframes + '\n';
        }

        // 套用動畫
        if (animations.length > 0) {
            img.style.animation = animations.join(', ');
        }

        // 套用濾鏡
        if (filters.length > 0) {
            img.style.filter = filters.join(' ');
        }

        // 淡入淡出
        if (movement.fade && movement.mode !== 'randomAppear') {
            img.style.animation = (img.style.animation ? img.style.animation + ', ' : '') + 'fade 2s ease-in-out infinite alternate';
            styleSheet.textContent += '@keyframes fade { from { opacity: 0.3; } to { opacity: 1; } }\n';
        }

        document.head.appendChild(styleSheet);

        // 視窗調整
        window.addEventListener('resize', () => {
            if (config.movement.mode === 'randomBounce') {
                location.reload();
            }
        });
        }
    </script>
</body>
</html>