<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics GIF Studio - ç‰©ç†GIFå·¥ä½œå®¤</title>
    <script src="js/gif.js"></script>
    <style>
        /* === åŸºç¤æ¨£å¼ === */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif; background: #121212; color: #e0e0e0; height: 100vh; display: flex; overflow: hidden; }
        
        .sidebar { width: 480px; background: #1e1e1e; border-right: 1px solid #333; display: flex; flex-direction: column; padding: 15px; overflow-y: auto; scrollbar-width: thin; scrollbar-color: #555 #1e1e1e; }
        .main-area { flex: 1; background-color: #252525; background-image: linear-gradient(45deg, #2a2a2a 25%, transparent 25%), linear-gradient(-45deg, #2a2a2a 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #2a2a2a 75%), linear-gradient(-45deg, transparent 75%, #2a2a2a 75%); background-size: 20px 20px; display: flex; align-items: center; justify-content: center; position: relative; }

        h1 { font-size: 1.2rem; color: #ffeb3b; text-align: center; margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .btn { width: 100%; padding: 10px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; transition: 0.2s; font-size: 0.9rem; }
        .btn-upload { background: #333; color: #aaa; border: 1px dashed #555; margin-bottom: 20px; }
        .btn-upload:hover { border-color: #ffeb3b; color: #fff; }
        .btn-record { background: #e91e63; color: white; margin-top: 20px; padding: 15px; font-size: 1.1rem; box-shadow: 0 -5px 20px rgba(0,0,0,0.5); }
        .btn-record:disabled { background: #444; cursor: not-allowed; }

        .panel-title { font-size: 0.85rem; color: #ffeb3b; margin: 25px 0 10px 0; border-left: 4px solid #ffeb3b; padding-left: 10px; font-weight: bold; background: #252525; padding: 5px 10px; border-radius: 0 4px 4px 0; }
        .panel-first { margin-top: 0; }

        .preset-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; margin-bottom: 10px; }
        .preset-btn { background: #2d2d2d; border: 1px solid #444; color: #ccc; padding: 8px 2px; border-radius: 4px; cursor: pointer; text-align: center; font-size: 0.75rem; transition: 0.2s; display: flex; align-items: center; justify-content: center; min-height: 36px; }
        .preset-btn:hover { border-color: #ffeb3b; color: #fff; background: #3a3a3a; }
        .preset-btn.active { background: #ffeb3b; color: #121212; border-color: #ffeb3b; font-weight: bold; }

        .control-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px 15px; background: #252525; padding: 10px; border-radius: 8px; border: 1px solid #333; }
        .full-width { grid-column: span 2; }
        
        .control-item { display: flex; flex-direction: column; }
        .control-item label { font-size: 0.7rem; color: #aaa; margin-bottom: 3px; display: flex; justify-content: space-between; }
        .control-item label span { color: #ffeb3b; font-family: monospace; font-size: 0.8rem; }
        
        select, input[type=number], input[type=text], input[type=color] { background: #181818; border: 1px solid #444; color: #eee; padding: 6px; border-radius: 4px; font-size: 0.8rem; width: 100%; }
        input[type=range] { width: 100%; accent-color: #ffeb3b; height: 5px; background: #444; border-radius: 3px; appearance: none; cursor: pointer; margin-top: 5px; }

        .toggle-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; margin-top: 5px; }
        .toggle-btn { position: relative; }
        .toggle-btn input { position: absolute; opacity: 0; cursor: pointer; height: 0; width: 0; }
        .toggle-btn label { display: block; background: #2d2d2d; color: #888; text-align: center; padding: 8px 0; font-size: 0.75rem; border-radius: 4px; cursor: pointer; border: 1px solid #444; transition: 0.2s; user-select: none; }
        .toggle-btn input:checked ~ label { background: #3a3a3a; color: #ffeb3b; border-color: #ffeb3b; font-weight: bold; }

        canvas { max-width: 95%; max-height: 95vh; box-shadow: 0 0 30px rgba(0,0,0,0.5); object-fit: contain; }
        #progress-overlay { position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 50; }
        #progress-bar { width: 300px; height: 8px; background: #444; border-radius: 4px; overflow: hidden; margin-top: 15px; }
        #progress-fill { width: 0%; height: 100%; background: #ffeb3b; transition: width 0.1s; }
    </style>
</head>
<body>

<div class="sidebar">
    <h1>Physics GIF Studio | ç‰©ç†GIFå·¥ä½œå®¤</h1>
    <button class="btn btn-upload" onclick="document.getElementById('fileIn').click()">ğŸ“‚ ä¸Šå‚³åœ–ç‰‡ï¼ˆPNG/JPGï¼‰</button>
    <input type="file" id="fileIn" accept="image/*" style="display: none">

    <div class="panel-title panel-first">å¿«é€Ÿç‰¹æ•ˆé¸å–®</div>
    <div class="preset-grid" id="quickPresetContainer"></div>

    <div class="panel-title">è©³ç´°æ§åˆ¶å°</div>
    <div class="control-grid">
        <div class="control-item full-width">
            <label>åœ–ç‰‡ç¸®æ”¾ <span id="val_baseScale">1.0</span></label>
            <input type="range" id="baseScale" min="0.1" max="1.5" step="0.05" value="0.8" oninput="updateParam('baseScale', this.value)">
        </div>
        <div class="control-item full-width">
            <label>ç‰©ç†æ¨¡å¼</label>
            <select id="physicsMode" onchange="updateParam('physicsMode', this.value)">
                <option value="none">ç„¡ (None)</option>
                <option value="ponpon">è¹¦è¹¦è·³ (Ponpon)</option>
                <option value="pyokopyoko">è¼•è·³ (Pyoko)</option>
                <option value="byonbyon">é«˜å½ˆç°§ (Byon)</option>
                <option value="kyorokyoro">æ±å¼µè¥¿æœ› (Kyoro)</option>
                <option value="urouro">å¾˜å¾Š (Uro)</option>
                <option value="tonton">è¼•æ‹ (Ton)</option>
                <option value="kururin">è‡ªè½‰ (Kuru)</option>
                <option value="poyunpoyun">è»Ÿå«© (Poyun)</option>
                <option value="zunzun">é€¼è¿‘ (Zun)</option>
                <option value="poin">å½ˆæ€§ (Poin)</option>
                <option value="fuwafuwa">é£„æµ® (Fuwa)</option>
                <option value="gatagata">æ’æ“Š (Gata)</option>
                <option value="yurayura">æ–æ“º (Yura)</option>
            </select>
        </div>
        <div class="control-item">
            <label>å¼·åº¦ (Strength) <span id="val_strength">0</span></label>
            <input type="range" id="strength" min="0" max="100" value="0" oninput="updateParam('strength', this.value)">
        </div>
        <div class="control-item">
            <label>é€Ÿåº¦ (Speed) <span id="val_speed">2</span></label>
            <input type="range" id="speed" min="0.1" max="30" step="0.1" value="2" oninput="updateParam('speed', this.value)">
        </div>
    </div>

    <div class="panel-title" style="margin-top:10px;">å‹•ä½œèˆ‡å¹¾ä½•</div>
    <div class="control-grid">
        <div class="control-item">
            <label>ç§»å‹•æ¨¡å¼</label>
            <select id="moveMode" onchange="updateParam('moveMode', this.value)">
                <option value="none">ç„¡ (None)</option>
                <option value="slideLeft">å·¦æ»‘å…¥</option>
                <option value="slideRight">å³æ»‘å…¥</option>
                <option value="slideUp">ä¸Šæ»‘å…¥</option>
                <option value="slideDown">ä¸‹æ»‘å…¥</option>
                <option value="parrot">é¸šéµ¡åœ“è»Œ</option>
                <option value="circleCustom">å¯èª¿åœ“å‘¨</option>
                <option value="horizontalLoop">æ°´å¹³ä¾†å›</option>
                <option value="verticalLoop">å‚ç›´ä¾†å›</option>
                <option value="zigzag">ä¹‹å­—å½¢</option>
                <option value="randomBounce">éš¨æ©Ÿå½ˆè·³</option>
            </select>
        </div>
        <div class="control-item">
            <label>ç§»å‹•è·é›¢ <span id="val_moveDist">400</span></label>
            <input type="range" id="moveDist" min="100" max="800" value="400" oninput="updateParam('moveDist', this.value)">
        </div>
        <div class="control-item">
            <label>åœ“å‘¨åŠå¾‘ <span id="val_circleRadius">100</span></label>
            <input type="range" id="circleRadius" min="50" max="400" value="100" oninput="updateParam('circleRadius', this.value)">
        </div>
        <div class="control-item">
            <label>ä¹‹å­—å¹…åº¦ <span id="val_zigzagAmp">50</span></label>
            <input type="range" id="zigzagAmp" min="20" max="200" value="50" oninput="updateParam('zigzagAmp', this.value)">
        </div>
        <div class="control-item">
            <label>ä¸å€’ç¿æ–æ“º <span id="val_wobble">0</span></label>
            <input type="range" id="wobble" min="0" max="90" value="0" oninput="updateParam('wobble', this.value)">
        </div>
        <div class="control-item">
            <label>æ—‹è½‰æ¨¡å¼</label>
            <select id="rotateMode" onchange="updateParam('rotateMode', this.value)">
                <option value="none">ç„¡ (None)</option>
                <option value="spinCW">é †æ™‚é‡</option>
                <option value="spinCCW">é€†æ™‚é‡</option>
            </select>
        </div>
        <div class="control-item">
            <label>ç¸®æ”¾/ç¿»è½‰</label>
            <select id="scaleMode" onchange="updateParam('scaleMode', this.value)">
                <option value="none">ç„¡ (None)</option>
                <option value="pulse">å¿ƒè·³è„ˆè¡</option>
                <option value="zoom">æŒçºŒæ”¾å¤§</option>
                <option value="flipH">å·¦å³é€£çºŒç¿»è½‰</option>
                <option value="flipV">ä¸Šä¸‹é€£çºŒç¿»è½‰</option>
            </select>
        </div>
    </div>

    <div class="panel-title" style="margin-top:10px;">è¦–è¦ºæ¿¾é¡</div>
    <div class="control-grid">
        <div class="control-item"><label>é€æ˜åº¦ <span id="val_opacity">100</span>%</label><input type="range" id="opacity" min="0" max="100" value="100" oninput="updateParam('opacity', this.value/100)"></div>
        <div class="control-item">
            <label>é™°å½±/ç™¼å…‰</label>
            <select id="shadowType" onchange="updateParam('shadowType', this.value)">
                <option value="none">ç„¡</option>
                <option value="drop">æŠ•å½±</option>
                <option value="glow">ç™¼å…‰</option>
            </select>
        </div>
        <div class="control-item"><label>é™°å½±å¼·åº¦ <span id="val_shadowBlur">10</span></label><input type="range" id="shadowBlur" min="0" max="50" value="10" oninput="updateParam('shadowBlur', this.value)"></div>
        <div class="control-item">
            <label>é™°å½±é¡è‰²</label>
            <input type="color" id="shadowColor" value="#000000" oninput="updateParam('shadowColor', this.value)">
        </div>
        <div class="control-item"><label>æ¨¡ç³Š <span id="val_blur">0</span></label><input type="range" id="blur" min="0" max="20" value="0" oninput="updateParam('blur', this.value)"></div>
        <div class="control-item"><label>é¦¬è³½å…‹ <span id="val_pixel">1</span></label><input type="range" id="pixel" min="1" max="30" value="1" oninput="updateParam('pixel', this.value)"></div>
        <div class="control-item"><label>æ³¢æµª <span id="val_wave">0</span></label><input type="range" id="wave" min="0" max="50" value="0" oninput="updateParam('wave', this.value)"></div>
        <div class="control-item"><label>é›œè¨Š <span id="val_noise">0</span></label><input type="range" id="noise" min="0" max="100" value="0" oninput="updateParam('noise', this.value)"></div>
        <div class="control-item"><label>æ•…éšœ <span id="val_glitch">0</span></label><input type="range" id="glitch" min="0" max="50" value="0" oninput="updateParam('glitch', this.value)"></div>
        <div class="control-item"><label>å½©è™¹ <span id="val_hue">0</span></label><input type="range" id="hue" min="0" max="50" value="0" oninput="updateParam('hue', this.value)"></div>
        <div class="control-item"><label>ç„¡é™éè¿´ <span id="val_recursive">0</span></label><input type="range" id="recursive" min="0" max="10" value="0" oninput="updateParam('recursive', this.value)"></div>
        <div class="control-item">
            <label>ç²’å­ç³»çµ±</label>
            <select id="particle" onchange="updateParam('particle', this.value)">
                <option value="none">ç„¡ (None)</option>
                <option value="snow">ä¸‹é›ª (Snow)</option>
                <option value="heart">æ„›å¿ƒ (Heart)</option>
                <option value="star">æ˜Ÿæ˜Ÿ (Star)</option>
                <option value="bubble">æ³¡æ³¡ (Bubble)</option>
                <option value="sakura">æ«»èŠ± (Sakura)</option>
                <option value="sparkle">é–ƒå…‰ (Sparkle)</option>
                <option value="firefly">è¢ç«èŸ² (Firefly)</option>
                <option value="confetti">å½©ç´™ (Confetti)</option>
            </select>
        </div>
        <div class="control-item">
            <label>ç²’å­é€Ÿåº¦ <span id="val_particleSpeed">0.1</span></label>
            <input type="range" id="particleSpeed" min="0" max="0.5" step="0.01" value="0.1" oninput="updateParam('particleSpeed', this.value)">
        </div>
    </div>

    <div class="panel-title" style="margin-top:10px;">èƒŒé¢èˆ‡é–‹é—œ</div>
    <div class="control-grid">
        <div class="control-item">
            <label>èƒŒé¢æ¨¡å¼ (ç¿»è½‰æ™‚)</label>
            <select id="backFaceMode" onchange="updateParam('backFaceMode', this.value)">
                <option value="mirror">é¡åƒ (Mirror)</option>
                <option value="darken">è®Šæš— (Shadow)</option>
                <option value="color">ç´”è‰² (Color)</option>
            </select>
        </div>
        <div class="control-item">
            <label>èƒŒé¢é¡è‰²</label>
            <div style="display:flex; gap:5px;">
                <input type="color" id="backFaceColor" value="#ffeb3b" style="width:40px;" oninput="updateParam('backFaceColor', this.value)">
                <input type="text" id="backFaceColorText" value="#ffeb3b" oninput="document.getElementById('backFaceColor').value=this.value; updateParam('backFaceColor', this.value)">
            </div>
        </div>
    </div>
    
    <div class="toggle-grid">
        <div class="toggle-btn"><input type="checkbox" id="mirror" onchange="updateParam('mirror', this.checked)"><label for="mirror">é¡åƒ (é›™äºº)</label></div>
        <div class="toggle-btn"><input type="checkbox" id="lake" onchange="updateParam('lake', this.checked)"><label for="lake">å€’å½± (æ°´é¢)</label></div>
        <div class="toggle-btn"><input type="checkbox" id="invert" onchange="updateParam('invert', this.checked)"><label for="invert">è² ç‰‡</label></div>
        <div class="toggle-btn"><input type="checkbox" id="sepia" onchange="updateParam('sepia', this.checked)"><label for="sepia">è€é›»å½±</label></div>
        <div class="toggle-btn"><input type="checkbox" id="grayscale" onchange="updateParam('grayscale', this.checked)"><label for="grayscale">ç°éš</label></div>
    </div>

    <div class="control-grid" id="lakeGapControl" style="margin-top: 10px; display: none;">
        <div class="control-item">
            <label>å€’å½±é–“è· <span id="val_lakeGap">0</span>px</label>
            <input type="range" id="lakeGap" min="-100" max="100" value="0" oninput="updateParam('lakeGap', this.value)">
        </div>
    </div>

    <div class="panel-title">è¼¸å‡ºè¨­å®š</div>
    <div class="control-grid">
        <div class="control-item"><label>å¯¬åº¦</label><input type="number" id="canvasW" value="300" onchange="updateCanvasSize()"></div>
        <div class="control-item"><label>é«˜åº¦</label><input type="number" id="canvasH" value="300" onchange="updateCanvasSize()"></div>
        <div class="control-item"><label>ç§’æ•¸</label><input type="number" id="duration" value="2" step="0.5"></div>
        <div class="control-item"><label>FPS</label><select id="fps"><option value="10">10</option><option value="15">15</option><option value="20" selected>20</option><option value="30">30</option></select></div>
        <div class="control-item full-width">
            <label>èƒŒæ™¯æ¨¡å¼</label>
            <select id="bgMode">
                <option value="transparent">é€æ˜èƒŒæ™¯</option>
                <option value="matte_white">å»èƒŒå„ªåŒ– (ç™½)</option>
                <option value="matte_black">å»èƒŒå„ªåŒ– (é»‘)</option>
                <option value="white">ç´”ç™½èƒŒæ™¯</option>
                <option value="black">ç´”é»‘èƒŒæ™¯</option>
                <option value="green">ç¶ å¹•</option>
            </select>
        </div>
    </div>

    <button class="btn btn-record" onclick="startRecording()" id="recBtn">ğŸ”´ éŒ„è£½ä¸¦ä¸‹è¼‰ GIF</button>
</div>

<div class="main-area">
    <canvas id="canvas"></canvas>
    <div id="progress-overlay">
        <h2 style="color:white; margin-bottom:10px;">è™•ç†ä¸­...</h2>
        <div id="progress-bar"><div id="progress-fill"></div></div>
        <p id="progress-text" style="color:#ccc; margin-top:8px; font-size:0.9rem;">0%</p>
    </div>
</div>

<script>
    // === 1. ç³»çµ±è®Šæ•¸ ===
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    let sourceImage = null;
    let sourceIsGif = false;
    let isLoaded = false;
    let animId;
    let time = 0;
    
    // åƒæ•¸ç‹€æ…‹
    const defaultParams = {
        baseScale: 0.8,
        physicsMode: 'none', strength: 30, speed: 2,
        moveMode: 'none', moveDist: 400, circleRadius: 100, zigzagAmp: 50,
        rotateMode: 'none', wobble: 0, scaleMode: 'none',
        blur: 0, pixel: 1, wave: 0, noise: 0, glitch: 0, hue: 0, recursive: 0,
        particle: 'none', particleSpeed: 0.1,
        backFaceMode: 'mirror', backFaceColor: '#ffeb3b',
        mirror: false, lake: false, lakeGap: 0, invert: false, sepia: false, grayscale: false,
        shadowType: 'none', shadowColor: '#000000', shadowBlur: 10,
        opacity: 1.0,
        offsetX: 0, offsetY: 0
    };
    let params = { ...defaultParams };
    let particles = [];

    // æ‹–æ›³ç‹€æ…‹
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;

    // === 2. å¿«é€Ÿé¸å–® ===
    const quickPresets = {
        "è¹¦è¹¦è·³": { physicsMode: 'ponpon', strength: 50, speed: 2 },
        "è»ŸQå½ˆè·³": { physicsMode: 'pyokopyoko', strength: 20, speed: 2 },
        "é«˜å½ˆç°§": { physicsMode: 'byonbyon', strength: 60, speed: 2 },
        "æ±å¼µè¥¿æœ›": { physicsMode: 'kyorokyoro', strength: 30, speed: 2 },
        "å¾˜å¾Š": { physicsMode: 'urouro', strength: 50, speed: 2 },
        "è¼•æ‹": { physicsMode: 'tonton', strength: 10, speed: 2 },
        "è‡ªè½‰": { physicsMode: 'kururin', strength: 0, speed: 2 },
        "è»Ÿå«©æœå‡": { physicsMode: 'poyunpoyun', strength: 50, speed: 2 },
        "é€¼è¿‘": { physicsMode: 'zunzun', strength: 20, speed: 2 },
        "å½ˆæ€§": { physicsMode: 'poin', strength: 40, speed: 2 },
        "é£„æµ®": { physicsMode: 'fuwafuwa', strength: 20, speed: 2 },
        "æ’æ“Š": { physicsMode: 'gatagata', strength: 15, speed: 2 },
        "æ–æ“º": { physicsMode: 'yurayura', strength: 15, speed: 2 },
        "å·¦æ»‘å…¥": { moveMode: 'slideLeft', moveDist: 400, speed: 2 },
        "å³æ»‘å…¥": { moveMode: 'slideRight', moveDist: 400, speed: 2 },
        "é¸šéµ¡è»Œè·¡": { moveMode: 'parrot', speed: 2 },
        "å¿ƒè·³": { scaleMode: 'pulse', speed: 2 },
        "å·¦å³ç¿»": { scaleMode: 'flipH', speed: 2 },
        "ä¸å€’ç¿": { wobble: 40, speed: 2 },
        "å½©è™¹": { hue: 10 },
        "æ•…éšœ": { glitch: 20, noise: 20 },
        "è€é›»å½±": { sepia: true, noise: 40, speed: 2 },
        "è² ç‰‡": { invert: true, speed: 2 },
        "æ¨¡ç³Š": { blur: 5 },
        "é¦¬è³½å…‹": { pixel: 8 },
        "æ³¢æµª": { wave: 20, speed: 2 },
        "é¡åƒ": { mirror: true },
        "å€’å½±": { lake: true },
        "ç„¡é™": { recursive: 5, speed: 2 },
        "ä¸‹é›ª": { particle: 'snow' },
        "æ„›å¿ƒ": { particle: 'heart' },
        "æ³¡æ³¡": { particle: 'bubble' },
        "æ«»èŠ±": { particle: 'sakura' },
        "é–ƒå…‰": { particle: 'sparkle' },
        "è¢ç«èŸ²": { particle: 'firefly' },
        "å½©ç´™": { particle: 'confetti' }
    };

    // === 3. åˆå§‹åŒ– ===
    function init() {
        const container = document.getElementById('quickPresetContainer');
        container.innerHTML = '';
        Object.keys(quickPresets).forEach(name => {
            const btn = document.createElement('div');
            btn.className = 'preset-btn';
            btn.innerText = name;
            btn.onclick = () => applyPreset(name, btn);
            container.appendChild(btn);
        });

        // ä¸é è¨­ä»»ä½•ç‰¹æ•ˆï¼Œä¿æŒåˆå§‹ç‹€æ…‹
        syncAllControls();

        updateCanvasSize();
        loop();
    }

    function applyPreset(name, btn) {
        params = { ...defaultParams };
        const p = quickPresets[name];
        if (p) Object.assign(params, p);
        
        document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
        if(btn && btn.classList) btn.classList.add('active');
        
        syncAllControls();
        initParticles();
        time = 0;
    }

    function syncAllControls() {
        const keys = [
            'baseScale', 'physicsMode', 'strength', 'speed', 'wobble',
            'moveMode', 'moveDist', 'circleRadius', 'zigzagAmp', 'rotateMode', 'scaleMode',
            'blur', 'pixel', 'wave', 'noise', 'glitch', 'hue', 'recursive', 'particle',
            'backFaceMode', 'shadowType', 'shadowBlur', 'particleSpeed', 'lakeGap'
        ];
        keys.forEach(k => {
            const el = document.getElementById(k);
            if(el) {
                el.value = params[k];
                const span = document.getElementById(`val_${k}`);
                if(span) {
                    if (k === 'opacity') {
                        span.innerText = Math.round(params[k] * 100);
                    } else {
                        span.innerText = params[k];
                    }
                }
            }
        });
        // é€æ˜åº¦ç‰¹æ®Šè™•ç†ï¼ˆ0-100%ï¼‰
        const opacitySlider = document.getElementById('opacity');
        if (opacitySlider) opacitySlider.value = params.opacity * 100;
        const opacitySpan = document.getElementById('val_opacity');
        if (opacitySpan) opacitySpan.innerText = Math.round(params.opacity * 100);

        ['mirror', 'lake', 'invert', 'sepia', 'grayscale'].forEach(k => {
            const el = document.getElementById(k);
            if(el) el.checked = params[k];
        });
        const colPick = document.getElementById('backFaceColor');
        if(colPick) colPick.value = params.backFaceColor;
        const shadowCol = document.getElementById('shadowColor');
        if(shadowCol) shadowCol.value = params.shadowColor;
    }

    function updateParam(key, value) {
        if (typeof defaultParams[key] === 'number') value = parseFloat(value);
        if (typeof defaultParams[key] === 'boolean') value = !!value;
        params[key] = value;
        if(typeof value === 'number') {
            const span = document.getElementById(`val_${key}`);
            if(span) {
                if (key === 'opacity') {
                    span.innerText = Math.round(value * 100);
                } else {
                    span.innerText = value;
                }
            }
        }
        if (key === 'particle') initParticles();

        // æ§åˆ¶å€’å½±é–“è·çš„é¡¯ç¤º/éš±è—
        if (key === 'lake') {
            const lakeGapControl = document.getElementById('lakeGapControl');
            if (lakeGapControl) {
                lakeGapControl.style.display = value ? 'grid' : 'none';
            }
        }
    }

    // === 4. æ¸²æŸ“æ ¸å¿ƒ (ä¿®å¾© Mirror/Lake) ===
    function drawScene(t) {
        const W = canvas.width;
        const H = canvas.height;
        
        ctx.clearRect(0, 0, W, H);
        if (!isLoaded) {
            ctx.fillStyle = '#666'; ctx.font = '16px sans-serif'; ctx.textAlign = 'center';
            ctx.fillText('è«‹ä¸Šå‚³éœæ…‹åœ–ç‰‡ï¼ˆPNG/JPGï¼‰', W/2, H/2); return;
        }

        const cx = W / 2 + params.offsetX;
        const cy = H / 2 + params.offsetY;

        // æ ¸å¿ƒé‚è¼¯ï¼šå…ˆæ±ºå®šã€Œå–®é«”ã€æ€éº¼ç•«ï¼Œå†æ±ºå®šã€Œå ´æ™¯ã€æ€éº¼æ“º

        // 1. ç•«æœ¬é«” (åŒ…å« Mirror é‚è¼¯)
        drawEntities(cx, cy, t, false);

        // 2. å¦‚æœæœ‰å€’å½± (Lake)ï¼Œåœ¨åŸåœ–ä¸‹æ–¹ç•«å€’å½±
        if (params.lake) {
            ctx.save();
            // è¨ˆç®—åœ–ç‰‡åŸºç¤é«˜åº¦ï¼ˆè€ƒæ…®å¯èƒ½çš„ç¸®æ”¾ï¼Œé ç•™å®‰å…¨é‚Šç•Œï¼‰
            const baseSize = Math.min(canvas.width, canvas.height) * params.baseScale;
            const ratio = sourceImage.width / sourceImage.height;
            let imgHeight = baseSize / ratio;
            if (ratio < 1) imgHeight = baseSize;

            // å€’å½±èµ·é» = åœ–ç‰‡ä¸­å¿ƒ + åœ–ç‰‡é«˜åº¦çš„ä¸€åŠï¼ˆå·²åŒ…å« baseScaleï¼‰+ è‡ªè¨‚é–“è·
            const reflectionTop = cy + imgHeight / 2 + params.lakeGap;

            // è¨­å®šå€’å½±å€åŸŸçš„è£åˆ‡ï¼ˆåªé¡¯ç¤ºåœ–ç‰‡ä¸‹æ–¹çš„å€’å½±ï¼‰
            ctx.beginPath();
            ctx.rect(0, reflectionTop, canvas.width, canvas.height - reflectionTop);
            ctx.clip();

            // å€’å½±ï¼šä»¥åœ–ç‰‡åº•éƒ¨ç‚ºè»¸ï¼Œå‚ç›´ç¿»è½‰
            ctx.translate(0, reflectionTop * 2);
            ctx.scale(1, -1);

            // ç¹ªè£½å€’å½±å…§å®¹ï¼ˆé™ä½é€æ˜åº¦ä¸¦åŠ ä¸Šç°è‰²æ¿¾é¡ï¼‰
            ctx.globalAlpha = 0.3;
            ctx.filter = 'brightness(0.5) saturate(0.3)'; // è®Šæš— + é™ä½é£½å’Œåº¦
            drawEntities(cx, cy, t, true);
            ctx.filter = 'none';

            ctx.restore();
        }

        // 3. ç•«æœ€ä¸Šå±¤ç²’å­
        drawParticles(t);
    }

    // ç¹ªè£½å¯¦é«” (è™•ç† Mirror)
    function drawEntities(cx, cy, t, isReflection) {
        const offset = params.mirror ? canvas.width * 0.2 : 0; // é¡åƒæ™‚å·¦å³åˆ†é–‹

        if (params.mirror) {
            // å·¦é‚Š (æœ¬å°Š)
            ctx.save();
            ctx.translate(-offset, 0);
            drawCharacter(cx, cy, t, false, isReflection);
            ctx.restore();

            // å³é‚Š (åˆ†èº«/é¡åƒ)
            ctx.save();
            ctx.translate(offset, 0);
            // é¡åƒç¿»è½‰ï¼šä»¥ä¸­å¿ƒç‚ºè»¸
            ctx.translate(cx, cy);
            ctx.scale(-1, 1);
            ctx.translate(-cx, -cy);
            drawCharacter(cx, cy, t, true, isReflection); // isMirrored = true
            ctx.restore();
        } else {
            // å–®ä¸€è§’è‰²
            drawCharacter(cx, cy, t, false, isReflection);
        }
    }

    // ç¹ªè£½å–®ä¸€è§’è‰² (æ‡‰ç”¨ç‰©ç†èˆ‡ç‰¹æ•ˆ)
    function drawCharacter(cx, cy, t, isMirroredObj, isReflection = false) {
        ctx.save();

        // å¥—ç”¨å…¨åŸŸé€æ˜åº¦ï¼ˆå€’å½±ä¸å—æ­¤å½±éŸ¿ï¼Œå¦å¤–è™•ç†ï¼‰
        if (!isReflection) {
            ctx.globalAlpha = params.opacity;
        }

        // å¥—ç”¨é™°å½±/ç™¼å…‰æ•ˆæœï¼ˆå€’å½±ä¸éœ€è¦é™°å½±ï¼‰
        if (!isReflection && params.shadowType === 'drop') {
            ctx.shadowColor = params.shadowColor;
            ctx.shadowBlur = params.shadowBlur;
            ctx.shadowOffsetX = params.shadowBlur * 0.3;
            ctx.shadowOffsetY = params.shadowBlur * 0.3;
        } else if (!isReflection && params.shadowType === 'glow') {
            ctx.shadowColor = params.shadowColor;
            ctx.shadowBlur = params.shadowBlur;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }

        ctx.translate(cx, cy);

        // --- ç‰©ç†è¨ˆç®— ---
        const spd = params.speed;
        const str = params.strength;
        const cycle = t * spd * 0.05;

        let poyoScaleX = 1, poyoScaleY = 1;
        let poyoX = 0, poyoY = 0;
        let poyoRot = 0;
        let pivotY = 0;

        switch (params.physicsMode) {
            case 'ponpon':
                const jumpH = str * 2;
                const bounce = Math.abs(Math.sin(cycle));
                poyoY = -bounce * jumpH + (jumpH * 0.5);
                poyoScaleX = Math.cos(cycle * 0.5) > 0 ? 1 : -1; 
                const impact = Math.max(0, 0.5 - bounce) * 0.5;
                poyoScaleY = 1 - impact;
                poyoScaleX *= (1 + impact);
                break;
            case 'pyokopyoko':
                poyoY = -Math.abs(Math.sin(cycle)) * (str * 0.5);
                const sq = Math.max(0, Math.cos(cycle * 2 + Math.PI/2)) * (str * 0.01);
                poyoScaleX = 1 + sq; poyoScaleY = 1 - sq;
                break;
            case 'kyorokyoro':
                poyoX = Math.sin(cycle * 0.5) * str;
                poyoRot = Math.sin(cycle * 0.5) * 0.1;
                break;
            case 'byonbyon':
                const st = Math.abs(Math.sin(cycle)) * (str * 0.03);
                poyoScaleY = 1 + st; poyoScaleX = 1 - st * 0.4;
                poyoY = (1 - poyoScaleY) * 50;
                break;
            case 'urouro':
                poyoX = Math.sin(cycle * 0.3) * str * 2;
                poyoY = Math.abs(Math.sin(cycle * 1.5)) * -10;
                poyoRot = Math.sin(cycle * 0.3) * 0.1;
                break;
            case 'tonton': poyoY = -Math.abs(Math.sin(cycle * 2)) * (str * 0.3); break;
            case 'kururin': poyoScaleX = Math.cos(cycle); break;
            case 'poyunpoyun':
                const s = Math.sin(cycle) * (str * 0.02);
                poyoScaleX = 1 + s; poyoScaleY = 1 - s;
                poyoRot = Math.sin(cycle * 0.5) * 0.1;
                break;
            case 'zunzun': const z = Math.sin(cycle) * (str * 0.02); poyoScaleX = 1 + z; poyoScaleY = 1 + z; break;
            case 'poin':
                const p = Math.sin(cycle) * (str * 0.015);
                poyoScaleY = 1 - p; poyoScaleX = 1 + p; poyoY = p * 50;
                break;
            case 'fuwafuwa': poyoY = Math.sin(cycle * 0.5) * str; break;
            case 'gatagata':
                poyoX = (Math.sin(cycle * 10) > 0 ? 1 : -1) * (str * 0.1);
                poyoY = (Math.cos(cycle * 10) > 0 ? 1 : -1) * (str * 0.1);
                break;
            case 'yurayura': pivotY = -100; poyoRot = Math.sin(cycle * 0.5) * (str * 0.01); break;
        }

        // --- Motion ---
        let motionX = 0, motionY = 0, motionRot = 0, motionScaleX = 1, motionScaleY = 1;
        if (params.moveMode === 'slideLeft') motionX = -params.moveDist * (1 - Math.min(1, (t%60)/30));
        if (params.moveMode === 'slideRight') motionX = params.moveDist * (1 - Math.min(1, (t%60)/30));
        if (params.moveMode === 'slideUp') motionY = -params.moveDist * (1 - Math.min(1, (t%60)/30));
        if (params.moveMode === 'slideDown') motionY = params.moveDist * (1 - Math.min(1, (t%60)/30));
        if (params.moveMode === 'parrot') { motionX = Math.cos(cycle)*40; motionY = Math.sin(cycle)*40; }
        if (params.moveMode === 'circleCustom') {
            motionX = Math.cos(cycle) * params.circleRadius;
            motionY = Math.sin(cycle) * params.circleRadius;
        }
        if (params.moveMode === 'horizontalLoop') {
            motionX = Math.sin(cycle * 0.5) * params.moveDist * 0.5;
        }
        if (params.moveMode === 'verticalLoop') {
            motionY = Math.sin(cycle * 0.5) * params.moveDist * 0.5;
        }
        if (params.moveMode === 'zigzag') {
            motionX = (t % 60) * (params.moveDist / 60) - params.moveDist * 0.5;
            motionY = Math.sin(cycle * 2) * params.zigzagAmp;
        }
        if (params.moveMode === 'randomBounce') {
            const bounceX = Math.sin(cycle * 1.3 + 1) * params.moveDist * 0.3;
            const bounceY = Math.sin(cycle * 1.7 + 2) * params.moveDist * 0.3;
            // ç¢°å£åå½ˆæ•ˆæœï¼ˆç°¡åŒ–ç‰ˆï¼‰
            motionX = bounceX;
            motionY = bounceY;
        }
        if (params.rotateMode === 'spinCW') motionRot = cycle;
        if (params.rotateMode === 'spinCCW') motionRot = -cycle;
        if (params.scaleMode === 'pulse') { const ps = 1+Math.sin(cycle)*0.1; motionScaleX=ps; motionScaleY=ps; }
        if (params.scaleMode === 'zoom') { const zs = 1+(t%30)*0.05; motionScaleX=zs; motionScaleY=zs; }
        if (params.scaleMode === 'flipH') motionScaleX = Math.sin(cycle);
        if (params.scaleMode === 'flipV') motionScaleY = Math.sin(cycle);
        if (params.wobble > 0) motionRot += Math.sin(cycle) * (params.wobble * 0.01);

        // --- ç¶œåˆ ---
        ctx.translate(poyoX + motionX, poyoY + motionY);
        const totalRot = poyoRot + motionRot;
        if (pivotY !== 0) { ctx.translate(0, pivotY); ctx.rotate(totalRot); ctx.translate(0, -pivotY); }
        else { ctx.rotate(totalRot); }

        const totalScaleX = poyoScaleX * motionScaleX;
        const totalScaleY = poyoScaleY * motionScaleY;
        
        // åˆ¤æ–·èƒŒé¢ï¼šå¦‚æœ totalScaleX ç‚ºè² ï¼Œè¡¨ç¤ºç¿»é¢äº†
        // æ³¨æ„ï¼šå¦‚æœæ˜¯ Mirror æ¨¡å¼ä¸‹çš„å³é‚Šè§’è‰² (isMirroredObj=true)ï¼Œå®ƒæœ¬èº«å°±è¢«å¤–éƒ¨ scale(-1, 1) éäº†
        // æ‰€ä»¥æˆ‘å€‘è¦ç¶œåˆåˆ¤æ–· "è¦–è¦ºä¸Šçš„ç¿»é¢"
        let finalScaleX = totalScaleX;
        // å¦‚æœæ˜¯ BackFace åˆ¤æ–·ï¼Œæˆ‘å€‘ä¸»è¦é—œå¿ƒ totalScaleX æœ¬èº«çš„ç¬¦è™Ÿ
        const isBackFace = totalScaleX < 0;

        ctx.scale(totalScaleX, totalScaleY);

        // --- ç¹ªåœ– ---
        const baseSize = Math.min(canvas.width, canvas.height) * params.baseScale;
        const ratio = sourceImage.width / sourceImage.height;
        let w = baseSize, h = baseSize / ratio;
        if (ratio < 1) { h = baseSize; w = baseSize * ratio; }
        const dx = -w/2, dy = -h/2;

        if (isBackFace && params.backFaceMode !== 'mirror') {
            // èƒŒé¢ç‰¹æ®Šè™•ç†
            // å› ç‚º scaleX æ˜¯è² çš„ï¼Œåº§æ¨™ç³»å·²ç¶“ç¿»è½‰ï¼Œæˆ‘å€‘ç•«åœ–æœƒæ˜¯é¡åƒçš„
            if (params.backFaceMode === 'color') {
                ctx.fillStyle = params.backFaceColor;
                ctx.fillRect(dx, dy, w, h);
            } else if (params.backFaceMode === 'darken') {
                drawImageWithFilters(dx, dy, w, h, t);
                ctx.globalCompositeOperation = 'source-atop';
                ctx.fillStyle = 'rgba(0,0,0,0.8)';
                ctx.fillRect(dx, dy, w, h);
                ctx.globalCompositeOperation = 'source-over';
            }
        } else {
            drawImageWithFilters(dx, dy, w, h, t);
        }

        ctx.restore();
    }

    function drawImageWithFilters(dx, dy, w, h, currentTime) {
        // ç›´æ¥ä½¿ç”¨ sourceImageï¼ˆç€è¦½å™¨æœƒè‡ªå‹•æ’­æ”¾ GIFï¼‰
        // æ¿¾é¡
        let f = "";
        if (params.hue > 0) f += `hue-rotate(${currentTime * params.hue * 2}deg) `;
        if (params.blur > 0) f += `blur(${params.blur}px) `;
        if (params.invert) {
            if(params.speed > 0) { if(Math.floor(currentTime / 5) % 2 === 0) f += `invert(100%) `; }
            else { f += `invert(100%) `; }
        }
        if (params.sepia) f += `sepia(100%) `;
        if (params.grayscale) f += `grayscale(100%) `;
        ctx.filter = f;

        if (params.glitch > 0) {
            const off = params.glitch;
            ctx.globalCompositeOperation = 'lighten';
            ctx.globalAlpha = 0.7;
            ctx.drawImage(sourceImage, dx - off, dy, w, h);
            ctx.drawImage(sourceImage, dx + off, dy, w, h);
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
        } else if (params.pixel > 1) {
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(sourceImage, dx, dy, w, h);
            ctx.imageSmoothingEnabled = true;
        } else if (params.wave > 0) {
            const slices = 20; const sw = sourceImage.height / slices; const sh = h / slices;
            for(let i=0; i<slices; i++) {
                const waveOff = Math.sin(currentTime * 0.2 + i * 0.5) * params.wave;
                ctx.drawImage(sourceImage, 0, i * sw, sourceImage.width, sw, dx + waveOff, dy + i * sh, w, sh);
            }
        } else if (params.noise > 0) {
            ctx.drawImage(sourceImage, dx, dy, w, h);
            ctx.globalCompositeOperation = "overlay";
            for(let i=0; i<5; i++) {
                ctx.fillStyle = `rgba(255,255,255,${Math.random()*params.noise/100})`;
                ctx.fillRect(dx+Math.random()*w, dy+Math.random()*h, Math.random()*30, 2);
            }
            ctx.globalCompositeOperation = "source-over";
        } else {
            ctx.drawImage(sourceImage, dx, dy, w, h);
        }
        ctx.filter = "none";

        // éè¿´æ•ˆæœ (Recursive)
        if (params.recursive > 0) {
             for(let i=params.recursive; i>0; i--) {
                ctx.save();
                const s = 1 - (i * 0.15);
                ctx.translate(dx+w/2, dy+h/2);
                ctx.scale(s, s);
                ctx.rotate(currentTime * 0.02 * i);
                ctx.translate(-(dx+w/2), -(dy+h/2));
                ctx.globalAlpha = 0.3;
                ctx.drawImage(sourceImage, dx, dy, w, h);
                ctx.restore();
            }
            ctx.globalAlpha = 1;
        }
    }

    // ç²’å­ç³»çµ±
    function initParticles() {
        particles = [];
        if (params.particle === 'none') return;
        const count = params.particle === 'sparkle' ? 30 : (params.particle === 'confetti' ? 150 : 15);

        // å›ºå®šä½ç½®çš„ç²’å­ï¼ˆæ„›å¿ƒã€æ˜Ÿæ˜Ÿã€é–ƒå…‰ï¼‰ä½¿ç”¨ç¶²æ ¼åˆ†å¸ƒ
        const useGrid = ['heart', 'star', 'sparkle'].includes(params.particle);

        if (useGrid) {
            // è¨ˆç®—ç¶²æ ¼å°ºå¯¸
            const cols = Math.ceil(Math.sqrt(count * (canvas.width / canvas.height)));
            const rows = Math.ceil(count / cols);
            const cellW = canvas.width / cols;
            const cellH = canvas.height / rows;

            let idx = 0;
            for(let row = 0; row < rows && idx < count; row++) {
                for(let col = 0; col < cols && idx < count; col++) {
                    // åœ¨æ¯å€‹ç¶²æ ¼å…§éš¨æ©Ÿåç§»ï¼Œé¿å…éæ–¼è¦å‰‡
                    const offsetX = (Math.random() - 0.5) * cellW * 0.6;
                    const offsetY = (Math.random() - 0.5) * cellH * 0.6;

                    particles.push({
                        startX: col * cellW + cellW / 2 + offsetX,
                        startY: row * cellH + cellH / 2 + offsetY,
                        s: Math.random()*0.5+0.6,
                        v: Math.random()*2+1,
                        o: Math.random()*Math.PI*2,
                        vx: (Math.random()-0.5)*2,
                        rotSpeed: (Math.random()-0.5)*5,
                        color: `hsl(${Math.random()*360}, 70%, 60%)`,
                        offset: Math.random() * 1000
                    });
                    idx++;
                }
            }
        } else {
            // ç§»å‹•ç²’å­ï¼ˆä¸‹é›ªã€æ³¡æ³¡ç­‰ï¼‰ä½¿ç”¨éš¨æ©Ÿåˆ†å¸ƒ
            for(let i=0; i<count; i++) {
                particles.push({
                    startX: Math.random()*canvas.width,
                    startY: Math.random()*canvas.height,
                    s: Math.random()*0.5+0.5,
                    v: Math.random()*2+1,
                    o: Math.random()*Math.PI*2,
                    vx: (Math.random()-0.5)*2,
                    rotSpeed: (Math.random()-0.5)*5,
                    color: `hsl(${Math.random()*360}, 70%, 60%)`,
                    offset: Math.random() * 1000
                });
            }
        }
    }
    function drawParticles(currentTime) {
        if (params.particle === 'none') return;
        ctx.save();
        particles.forEach(p => {
            // åŸºæ–¼æ™‚é–“è¨ˆç®—ä½ç½®ï¼ˆä¸ç´¯ç©ä¿®æ”¹ï¼‰
            // ä½¿ç”¨å¯èª¿æ•´çš„æ™‚é–“å°ºåº¦
            const t = (currentTime * params.particleSpeed) + p.offset;
            let x, y, rot;

            // ä½¿ç”¨å›ºå®šå¾ªç’°é€±æœŸï¼Œç¢ºä¿å®Œç¾å¾ªç’°
            const cycleHeight = canvas.height + 60; // å¾ªç’°å€åŸŸé«˜åº¦ï¼ˆå«ç·©è¡ï¼‰
            const cycleWidth = canvas.width + 60;

            if (params.particle === 'bubble') {
                // å‘ä¸Šé£„ï¼Œä½¿ç”¨æ¨¡é‹ç®—ç¢ºä¿å¹³æ»‘å¾ªç’°
                const movement = (t * p.v * 0.5) % cycleHeight;
                y = (p.startY - movement + cycleHeight) % cycleHeight - 30;
                x = p.startX + Math.sin(t * 0.05 + p.o) * 30;
                x = ((x % cycleWidth) + cycleWidth) % cycleWidth - 30;
            } else if (params.particle === 'sakura') {
                // å‘ä¸‹é£„è½ + å·¦å³æ“ºå‹•
                const movement = (t * p.v * 0.8) % cycleHeight;
                y = (p.startY + movement) % cycleHeight - 30;
                x = p.startX + Math.sin(t * 0.03 + p.o) * 50;
                x = ((x % cycleWidth) + cycleWidth) % cycleWidth - 30;
                rot = t * p.rotSpeed;
            } else if (params.particle === 'firefly') {
                // åœ“å‘¨é‹å‹•ï¼Œå®Œç¾å¾ªç’°
                y = canvas.height / 2 + Math.sin(t * 0.05 + p.o) * (canvas.height * 0.4);
                x = canvas.width / 2 + Math.cos(t * 0.05 + p.o) * (canvas.width * 0.4);
            } else if (params.particle === 'confetti') {
                // å½©ç´™ä¸‹è½ + æ°´å¹³é£„ç§»
                const movement = (t * p.v) % cycleHeight;
                y = (p.startY + movement) % cycleHeight - 30;
                const xMovement = (t * p.vx) % cycleWidth;
                x = (p.startX + xMovement + cycleWidth) % cycleWidth - 30;
                rot = t * p.rotSpeed;
            } else if (params.particle === 'heart' || params.particle === 'star' || params.particle === 'sparkle') {
                // æ„›å¿ƒã€æ˜Ÿæ˜Ÿã€é–ƒå…‰ - å›ºå®šä½ç½®ï¼Œæ”¾å¤§ç¸®å°å‹•ç•«
                x = p.startX;
                y = p.startY;
            } else {
                // ä¸‹é›ª - å‚ç›´ä¸‹è½
                const movement = (t * p.v) % cycleHeight;
                y = (p.startY + movement) % cycleHeight - 30;
                x = p.startX;
            }

            ctx.save();
            ctx.translate(x, y);
            if (params.particle === 'sakura' || params.particle === 'confetti') {
                ctx.rotate(rot * Math.PI / 180);
            }

            // æ„›å¿ƒã€æ˜Ÿæ˜Ÿã€é–ƒå…‰ä½¿ç”¨æ”¾å¤§ç¸®å°å‹•ç•«
            if (params.particle === 'heart' || params.particle === 'star' || params.particle === 'sparkle') {
                const pulseScale = p.s * (0.8 + Math.abs(Math.sin(t * 0.1 + p.o)) * 0.5);
                ctx.scale(pulseScale, pulseScale);
            } else {
                ctx.scale(p.s, p.s);
            }

            // ç¹ªè£½ä¸åŒç²’å­
            if (params.particle === 'snow') {
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath();
                ctx.arc(0, 0, 5, 0, Math.PI*2);
                ctx.fill();
            } else if (params.particle === 'heart') {
                ctx.fillStyle = `rgba(255, 50, 50, 0.9)`;
                ctx.font = "30px Arial";
                ctx.textAlign = "center";
                ctx.fillText("â¤", 0, 0);
            } else if (params.particle === 'star') {
                ctx.fillStyle = `rgba(255, 255, 100, ${Math.abs(Math.sin(currentTime*0.1+p.o))})`;
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI*2);
                ctx.fill();
            } else if (params.particle === 'bubble') {
                ctx.strokeStyle = `rgba(100, 200, 255, 0.6)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI*2);
                ctx.stroke();
                ctx.fillStyle = `rgba(255, 255, 255, 0.2)`;
                ctx.fill();
            } else if (params.particle === 'sakura') {
                ctx.fillStyle = `rgba(255, 182, 193, 0.8)`;
                ctx.font = "25px Arial";
                ctx.textAlign = "center";
                ctx.fillText("ğŸŒ¸", 0, 0);
            } else if (params.particle === 'sparkle') {
                const alpha = Math.abs(Math.sin(currentTime*0.15+p.o));
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.moveTo(0, -6);
                ctx.lineTo(0, 6);
                ctx.moveTo(-6, 0);
                ctx.lineTo(6, 0);
                ctx.lineWidth = 2;
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.stroke();
            } else if (params.particle === 'firefly') {
                const alpha = Math.abs(Math.sin(currentTime*0.2+p.o));
                ctx.fillStyle = `rgba(255, 255, 100, ${alpha})`;
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(255, 255, 100, ${alpha})`;
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;
            } else if (params.particle === 'confetti') {
                ctx.fillStyle = p.color;
                ctx.fillRect(-4, -8, 8, 16);
            }

            ctx.restore();
        });
        ctx.restore();
    }

    function loop() {
        if(!document.getElementById('recBtn').disabled) {
            // æ ¹æ“š speed åƒæ•¸èª¿æ•´æ™‚é–“æµé€é€Ÿåº¦
            // speed è¶Šå¤§ï¼Œå‹•ç•«è¶Šå¿«
            time += params.speed;
            drawScene(time);
            animId = requestAnimationFrame(loop);
        }
    }

    function updateCanvasSize() {
        let w = parseInt(document.getElementById('canvasW').value) || 300;
        let h = parseInt(document.getElementById('canvasH').value) || 300;
        canvas.width = w; canvas.height = h;
        initParticles();
    }

    document.getElementById('fileIn').addEventListener('change', async (e) => {
        if(e.target.files && e.target.files[0]) {
            const file = e.target.files[0];
            const blobUrl = URL.createObjectURL(file);

            sourceImage = new Image();
            sourceImage.onload = () => {
                isLoaded = true;
                sourceIsGif = file.type === 'image/gif';

                if (sourceIsGif) {
                    console.log('âš ï¸ GIF æª”æ¡ˆåµæ¸¬åˆ° - åƒ…ä½¿ç”¨ç¬¬ä¸€å¹€');
                    alert('âš ï¸ GIF æª”æ¡ˆæé†’\n\nç”±æ–¼ç€è¦½å™¨ Canvas API çš„æŠ€è¡“é™åˆ¶ï¼Œ\nGIF å‹•ç•«åªæœƒä½¿ç”¨ç¬¬ä¸€å¹€è£½ä½œã€‚\n\nå»ºè­°ï¼š\nâ€¢ ä½¿ç”¨éœæ…‹åœ–ç‰‡ï¼ˆPNG/JPGï¼‰ç²å¾—æœ€ä½³æ•ˆæœ\nâ€¢ æ­é…æœ¬å·¥å…·çš„ 13 ç¨®ç‰©ç†ç‰¹æ•ˆå‰µé€ å‹•æ…‹æ•ˆæœ');
                }

                console.log('åœ–ç‰‡è¼‰å…¥:', sourceIsGif ? 'GIFï¼ˆåƒ…ç¬¬ä¸€å¹€ï¼‰' : 'éœæ…‹åœ–ç‰‡',
                           'Size:', sourceImage.width, 'x', sourceImage.height);
                updateCanvasSize();
                canvas.style.cursor = 'grab';
            };
            sourceImage.src = blobUrl;
        }
    });

    // éŒ„è£½
    function startRecording() {
        if(!isLoaded) { alert("è«‹å…ˆä¸Šå‚³åœ–ç‰‡"); return; }
        const btn = document.getElementById('recBtn');
        const overlay = document.getElementById('progress-overlay');
        const bar = document.getElementById('progress-fill');
        const txt = document.getElementById('progress-text');
        btn.disabled = true; overlay.style.display = 'flex';
        cancelAnimationFrame(animId);

        const fps = parseInt(document.getElementById('fps').value);
        const duration = parseFloat(document.getElementById('duration').value);
        const totalFrames = fps * duration;
        const bgMode = document.getElementById('bgMode').value;

        let transparentColor = 0x0000; let bgColor = null;
        if (bgMode === 'matte_white') { transparentColor = 0xFFFFFF; bgColor = '#FFFFFF'; }
        else if (bgMode === 'matte_black') { transparentColor = 0x000000; bgColor = '#000000'; }
        else if (bgMode === 'transparent') { transparentColor = 0x0000; bgColor = null; }
        else if (bgMode === 'white') { transparentColor = null; bgColor = '#FFFFFF'; }
        else if (bgMode === 'black') { transparentColor = null; bgColor = '#000000'; }
        else if (bgMode === 'green') { transparentColor = null; bgColor = '#00FF00'; }

        // å»ºç«‹ Worker Blob URLï¼ˆè§£æ±º file:// CORS å•é¡Œï¼‰
        const workerBlob = new Blob([document.getElementById('worker-code').textContent], {
            type: 'application/javascript'
        });
        const workerBlobUrl = URL.createObjectURL(workerBlob);

        const gif = new GIF({
            workers: 2,
            quality: 10,
            width: canvas.width,
            height: canvas.height,
            workerScript: workerBlobUrl,
            transparent: transparentColor,
            background: bgColor
        });

        console.log('GIF è¨­å®š:', {
            å°ºå¯¸: `${canvas.width}x${canvas.height}`,
            å¹€æ•¸: totalFrames,
            FPS: fps,
            èƒŒæ™¯: bgMode
        });

        let frame = 0;
        let currentTime = 0;
        // è¨ˆç®—æ¯å¹€æ™‚é–“å¢é‡ï¼šé è¦½æ˜¯ 60fps * speedï¼ŒéŒ„è£½è¦åŒæ­¥é€™å€‹é€Ÿåº¦
        const timeIncrement = (60 * params.speed) / fps;
        function process() {
            if (bgColor) { ctx.fillStyle = bgColor; ctx.fillRect(0, 0, canvas.width, canvas.height); }
            else { ctx.clearRect(0,0,canvas.width, canvas.height); }

            // ç¹ªè£½è©²å¹€
            drawScene(currentTime);
            currentTime += timeIncrement;

            gif.addFrame(ctx, {copy: true, delay: 1000/fps});
            frame++;
            const pct = Math.round((frame/totalFrames)*50);
            bar.style.width = pct + "%"; txt.innerText = `éŒ„è£½ä¸­... ${pct}%`;

            if(frame < totalFrames) {
                // ä½¿ç”¨ requestAnimationFrame ç¢ºä¿ GIF å¹€æ›´æ–°
                requestAnimationFrame(process);
            } else {
                txt.innerText = "ç·¨ç¢¼ä¸­ (Encoding)...";

                gif.on('progress', p => {
                    const rp = 50 + Math.round(p*50);
                    bar.style.width = rp + "%"; txt.innerText = `è¼¸å‡ºä¸­... ${rp}%`;
                    console.log('GIF ç·¨ç¢¼é€²åº¦:', Math.round(p*100) + '%');
                });

                gif.on('finished', blob => {
                    console.log('GIF ç·¨ç¢¼å®Œæˆï¼Œæª”æ¡ˆå¤§å°:', Math.round(blob.size/1024) + 'KB');
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `effect_${Date.now()}.gif`;
                    link.click();
                    btn.disabled = false; overlay.style.display = 'none';
                    loop();
                });

                gif.on('error', (err) => {
                    console.error('GIF ç·¨ç¢¼éŒ¯èª¤:', err);
                    alert('GIF ç”¢ç”Ÿå¤±æ•—ï¼š' + err.message);
                    btn.disabled = false;
                    overlay.style.display = 'none';
                    loop();
                });

                console.log('é–‹å§‹æ¸²æŸ“ GIFï¼Œç¸½å¹€æ•¸:', totalFrames);
                gif.render();
            }
        }
        process();
    }

    // æ‹–æ›³äº‹ä»¶
    canvas.addEventListener('mousedown', (e) => {
        if (!isLoaded) return;
        isDragging = true;
        const rect = canvas.getBoundingClientRect();
        dragStartX = e.clientX - rect.left - params.offsetX;
        dragStartY = e.clientY - rect.top - params.offsetY;
        canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const rect = canvas.getBoundingClientRect();
        params.offsetX = e.clientX - rect.left - dragStartX;
        params.offsetY = e.clientY - rect.top - dragStartY;
    });

    canvas.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = isLoaded ? 'grab' : 'default';
    });

    canvas.addEventListener('mouseleave', () => {
        isDragging = false;
        canvas.style.cursor = isLoaded ? 'grab' : 'default';
    });

    init();
</script>

<script id="worker-code" type="javascript/worker">
// gif.worker.js 0.2.0 - https://github.com/jnordberg/gif.js
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){var NeuQuant=require("./TypedNeuQuant.js");var LZWEncoder=require("./LZWEncoder.js");function ByteArray(){this.page=-1;this.pages=[];this.newPage()}ByteArray.pageSize=4096;ByteArray.charMap={};for(var i=0;i<256;i++)ByteArray.charMap[i]=String.fromCharCode(i);ByteArray.prototype.newPage=function(){this.pages[++this.page]=new Uint8Array(ByteArray.pageSize);this.cursor=0};ByteArray.prototype.getData=function(){var rv="";for(var p=0;p<this.pages.length;p++){for(var i=0;i<ByteArray.pageSize;i++){rv+=ByteArray.charMap[this.pages[p][i]]}}return rv};ByteArray.prototype.writeByte=function(val){if(this.cursor>=ByteArray.pageSize)this.newPage();this.pages[this.page][this.cursor++]=val};ByteArray.prototype.writeUTFBytes=function(string){for(var l=string.length,i=0;i<l;i++)this.writeByte(string.charCodeAt(i))};ByteArray.prototype.writeBytes=function(array,offset,length){for(var l=length||array.length,i=offset||0;i<l;i++)this.writeByte(array[i])};function GIFEncoder(width,height){this.width=~~width;this.height=~~height;this.transparent=null;this.transIndex=0;this.repeat=-1;this.delay=0;this.image=null;this.pixels=null;this.indexedPixels=null;this.colorDepth=null;this.colorTab=null;this.neuQuant=null;this.usedEntry=new Array;this.palSize=7;this.dispose=-1;this.firstFrame=true;this.sample=10;this.dither=false;this.globalPalette=false;this.out=new ByteArray}GIFEncoder.prototype.setDelay=function(milliseconds){this.delay=Math.round(milliseconds/10)};GIFEncoder.prototype.setFrameRate=function(fps){this.delay=Math.round(100/fps)};GIFEncoder.prototype.setDispose=function(disposalCode){if(disposalCode>=0)this.dispose=disposalCode};GIFEncoder.prototype.setRepeat=function(repeat){this.repeat=repeat};GIFEncoder.prototype.setTransparent=function(color){this.transparent=color};GIFEncoder.prototype.addFrame=function(imageData){this.image=imageData;this.colorTab=this.globalPalette&&this.globalPalette.slice?this.globalPalette:null;this.getImagePixels();this.analyzePixels();if(this.globalPalette===true)this.globalPalette=this.colorTab;if(this.firstFrame){this.writeLSD();this.writePalette();if(this.repeat>=0){this.writeNetscapeExt()}}this.writeGraphicCtrlExt();this.writeImageDesc();if(!this.firstFrame&&!this.globalPalette)this.writePalette();this.writePixels();this.firstFrame=false};GIFEncoder.prototype.finish=function(){this.out.writeByte(59)};GIFEncoder.prototype.setQuality=function(quality){if(quality<1)quality=1;this.sample=quality};GIFEncoder.prototype.setDither=function(dither){if(dither===true)dither="FloydSteinberg";this.dither=dither};GIFEncoder.prototype.setGlobalPalette=function(palette){this.globalPalette=palette};GIFEncoder.prototype.getGlobalPalette=function(){return this.globalPalette&&this.globalPalette.slice&&this.globalPalette.slice(0)||this.globalPalette};GIFEncoder.prototype.writeHeader=function(){this.out.writeUTFBytes("GIF89a")};GIFEncoder.prototype.analyzePixels=function(){if(!this.colorTab){this.neuQuant=new NeuQuant(this.pixels,this.sample);this.neuQuant.buildColormap();this.colorTab=this.neuQuant.getColormap()}if(this.dither){this.ditherPixels(this.dither.replace("-serpentine",""),this.dither.match(/-serpentine/)!==null)}else{this.indexPixels()}this.pixels=null;this.colorDepth=8;this.palSize=7;if(this.transparent!==null){this.transIndex=this.findClosest(this.transparent,true)}};GIFEncoder.prototype.indexPixels=function(imgq){var nPix=this.pixels.length/3;this.indexedPixels=new Uint8Array(nPix);var k=0;for(var j=0;j<nPix;j++){var index=this.findClosestRGB(this.pixels[k++]&255,this.pixels[k++]&255,this.pixels[k++]&255);this.usedEntry[index]=true;this.indexedPixels[j]=index}};GIFEncoder.prototype.ditherPixels=function(kernel,serpentine){var kernels={FalseFloydSteinberg:[[3/8,1,0],[3/8,0,1],[2/8,1,1]],FloydSteinberg:[[7/16,1,0],[3/16,-1,1],[5/16,0,1],[1/16,1,1]],Stucki:[[8/42,1,0],[4/42,2,0],[2/42,-2,1],[4/42,-1,1],[8/42,0,1],[4/42,1,1],[2/42,2,1],[1/42,-2,2],[2/42,-1,2],[4/42,0,2],[2/42,1,2],[1/42,2,2]],Atkinson:[[1/8,1,0],[1/8,2,0],[1/8,-1,1],[1/8,0,1],[1/8,1,1],[1/8,0,2]]};if(!kernel||!kernels[kernel]){throw"Unknown dithering kernel: "+kernel}var ds=kernels[kernel];var index=0,height=this.height,width=this.width,data=this.pixels;var direction=serpentine?-1:1;this.indexedPixels=new Uint8Array(this.pixels.length/3);for(var y=0;y<height;y++){if(serpentine)direction=direction*-1;for(var x=direction==1?0:width-1,xend=direction==1?width:0;x!==xend;x+=direction){index=y*width+x;var idx=index*3;var r1=data[idx];var g1=data[idx+1];var b1=data[idx+2];idx=this.findClosestRGB(r1,g1,b1);this.usedEntry[idx]=true;this.indexedPixels[index]=idx;idx*=3;var r2=this.colorTab[idx];var g2=this.colorTab[idx+1];var b2=this.colorTab[idx+2];var er=r1-r2;var eg=g1-g2;var eb=b1-b2;for(var i=direction==1?0:ds.length-1,end=direction==1?ds.length:0;i!==end;i+=direction){var x1=ds[i][1];var y1=ds[i][2];if(x1+x>=0&&x1+x<width&&y1+y>=0&&y1+y<height){var d=ds[i][0];idx=index+x1+y1*width;idx*=3;data[idx]=Math.max(0,Math.min(255,data[idx]+er*d));data[idx+1]=Math.max(0,Math.min(255,data[idx+1]+eg*d));data[idx+2]=Math.max(0,Math.min(255,data[idx+2]+eb*d))}}}}};GIFEncoder.prototype.findClosest=function(c,used){return this.findClosestRGB((c&16711680)>>16,(c&65280)>>8,c&255,used)};GIFEncoder.prototype.findClosestRGB=function(r,g,b,used){if(this.colorTab===null)return-1;if(this.neuQuant&&!used){return this.neuQuant.lookupRGB(r,g,b)}var c=b|g<<8|r<<16;var minpos=0;var dmin=256*256*256;var len=this.colorTab.length;for(var i=0,index=0;i<len;index++){var dr=r-(this.colorTab[i++]&255);var dg=g-(this.colorTab[i++]&255);var db=b-(this.colorTab[i++]&255);var d=dr*dr+dg*dg+db*db;if((!used||this.usedEntry[index])&&d<dmin){dmin=d;minpos=index}}return minpos};GIFEncoder.prototype.getImagePixels=function(){var w=this.width;var h=this.height;this.pixels=new Uint8Array(w*h*3);var data=this.image;var srcPos=0;var count=0;for(var i=0;i<h;i++){for(var j=0;j<w;j++){this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];srcPos++}}};GIFEncoder.prototype.writeGraphicCtrlExt=function(){this.out.writeByte(33);this.out.writeByte(249);this.out.writeByte(4);var transp,disp;if(this.transparent===null){transp=0;disp=0}else{transp=1;disp=2}if(this.dispose>=0){disp=dispose&7}disp<<=2;this.out.writeByte(0|disp|0|transp);this.writeShort(this.delay);this.out.writeByte(this.transIndex);this.out.writeByte(0)};GIFEncoder.prototype.writeImageDesc=function(){this.out.writeByte(44);this.writeShort(0);this.writeShort(0);this.writeShort(this.width);this.writeShort(this.height);if(this.firstFrame||this.globalPalette){this.out.writeByte(0)}else{this.out.writeByte(128|0|0|0|this.palSize)}};GIFEncoder.prototype.writeLSD=function(){this.writeShort(this.width);this.writeShort(this.height);this.out.writeByte(128|112|0|this.palSize);this.out.writeByte(0);this.out.writeByte(0)};GIFEncoder.prototype.writeNetscapeExt=function(){this.out.writeByte(33);this.out.writeByte(255);this.out.writeByte(11);this.out.writeUTFBytes("NETSCAPE2.0");this.out.writeByte(3);this.out.writeByte(1);this.writeShort(this.repeat);this.out.writeByte(0)};GIFEncoder.prototype.writePalette=function(){this.out.writeBytes(this.colorTab);var n=3*256-this.colorTab.length;for(var i=0;i<n;i++)this.out.writeByte(0)};GIFEncoder.prototype.writeShort=function(pValue){this.out.writeByte(pValue&255);this.out.writeByte(pValue>>8&255)};GIFEncoder.prototype.writePixels=function(){var enc=new LZWEncoder(this.width,this.height,this.indexedPixels,this.colorDepth);enc.encode(this.out)};GIFEncoder.prototype.stream=function(){return this.out};module.exports=GIFEncoder},{"./LZWEncoder.js":2,"./TypedNeuQuant.js":3}],2:[function(require,module,exports){var EOF=-1;var BITS=12;var HSIZE=5003;var masks=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];function LZWEncoder(width,height,pixels,colorDepth){var initCodeSize=Math.max(2,colorDepth);var accum=new Uint8Array(256);var htab=new Int32Array(HSIZE);var codetab=new Int32Array(HSIZE);var cur_accum,cur_bits=0;var a_count;var free_ent=0;var maxcode;var clear_flg=false;var g_init_bits,ClearCode,EOFCode;function char_out(c,outs){accum[a_count++]=c;if(a_count>=254)flush_char(outs)}function cl_block(outs){cl_hash(HSIZE);free_ent=ClearCode+2;clear_flg=true;output(ClearCode,outs)}function cl_hash(hsize){for(var i=0;i<hsize;++i)htab[i]=-1}function compress(init_bits,outs){var fcode,c,i,ent,disp,hsize_reg,hshift;g_init_bits=init_bits;clear_flg=false;n_bits=g_init_bits;maxcode=MAXCODE(n_bits);ClearCode=1<<init_bits-1;EOFCode=ClearCode+1;free_ent=ClearCode+2;a_count=0;ent=nextPixel();hshift=0;for(fcode=HSIZE;fcode<65536;fcode*=2)++hshift;hshift=8-hshift;hsize_reg=HSIZE;cl_hash(hsize_reg);output(ClearCode,outs);outer_loop:while((c=nextPixel())!=EOF){fcode=(c<<BITS)+ent;i=c<<hshift^ent;if(htab[i]===fcode){ent=codetab[i];continue}else if(htab[i]>=0){disp=hsize_reg-i;if(i===0)disp=1;do{if((i-=disp)<0)i+=hsize_reg;if(htab[i]===fcode){ent=codetab[i];continue outer_loop}}while(htab[i]>=0)}output(ent,outs);ent=c;if(free_ent<1<<BITS){codetab[i]=free_ent++;htab[i]=fcode}else{cl_block(outs)}}output(ent,outs);output(EOFCode,outs)}function encode(outs){outs.writeByte(initCodeSize);remaining=width*height;curPixel=0;compress(initCodeSize+1,outs);outs.writeByte(0)}function flush_char(outs){if(a_count>0){outs.writeByte(a_count);outs.writeBytes(accum,0,a_count);a_count=0}}function MAXCODE(n_bits){return(1<<n_bits)-1}function nextPixel(){if(remaining===0)return EOF;--remaining;var pix=pixels[curPixel++];return pix&255}function output(code,outs){cur_accum&=masks[cur_bits];if(cur_bits>0)cur_accum|=code<<cur_bits;else cur_accum=code;cur_bits+=n_bits;while(cur_bits>=8){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}if(free_ent>maxcode||clear_flg){if(clear_flg){maxcode=MAXCODE(n_bits=g_init_bits);clear_flg=false}else{++n_bits;if(n_bits==BITS)maxcode=1<<BITS;else maxcode=MAXCODE(n_bits)}}if(code==EOFCode){while(cur_bits>0){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}flush_char(outs)}}this.encode=encode}module.exports=LZWEncoder},{}],3:[function(require,module,exports){var ncycles=100;var netsize=256;var maxnetpos=netsize-1;var netbiasshift=4;var intbiasshift=16;var intbias=1<<intbiasshift;var gammashift=10;var gamma=1<<gammashift;var betashift=10;var beta=intbias>>betashift;var betagamma=intbias<<gammashift-betashift;var initrad=netsize>>3;var radiusbiasshift=6;var radiusbias=1<<radiusbiasshift;var initradius=initrad*radiusbias;var radiusdec=30;var alphabiasshift=10;var initalpha=1<<alphabiasshift;var alphadec;var radbiasshift=8;var radbias=1<<radbiasshift;var alpharadbshift=alphabiasshift+radbiasshift;var alpharadbias=1<<alpharadbshift;var prime1=499;var prime2=491;var prime3=487;var prime4=503;var minpicturebytes=3*prime4;function NeuQuant(pixels,samplefac){var network;var netindex;var bias;var freq;var radpower;function init(){network=[];netindex=new Int32Array(256);bias=new Int32Array(netsize);freq=new Int32Array(netsize);radpower=new Int32Array(netsize>>3);var i,v;for(i=0;i<netsize;i++){v=(i<<netbiasshift+8)/netsize;network[i]=new Float64Array([v,v,v,0]);freq[i]=intbias/netsize;bias[i]=0}}function unbiasnet(){for(var i=0;i<netsize;i++){network[i][0]>>=netbiasshift;network[i][1]>>=netbiasshift;network[i][2]>>=netbiasshift;network[i][3]=i}}function altersingle(alpha,i,b,g,r){network[i][0]-=alpha*(network[i][0]-b)/initalpha;network[i][1]-=alpha*(network[i][1]-g)/initalpha;network[i][2]-=alpha*(network[i][2]-r)/initalpha}function alterneigh(radius,i,b,g,r){var lo=Math.abs(i-radius);var hi=Math.min(i+radius,netsize);var j=i+1;var k=i-1;var m=1;var p,a;while(j<hi||k>lo){a=radpower[m++];if(j<hi){p=network[j++];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}if(k>lo){p=network[k--];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}}}function contest(b,g,r){var bestd=~(1<<31);var bestbiasd=bestd;var bestpos=-1;var bestbiaspos=bestpos;var i,n,dist,biasdist,betafreq;for(i=0;i<netsize;i++){n=network[i];dist=Math.abs(n[0]-b)+Math.abs(n[1]-g)+Math.abs(n[2]-r);if(dist<bestd){bestd=dist;bestpos=i}biasdist=dist-(bias[i]>>intbiasshift-netbiasshift);if(biasdist<bestbiasd){bestbiasd=biasdist;bestbiaspos=i}betafreq=freq[i]>>betashift;freq[i]-=betafreq;bias[i]+=betafreq<<gammashift}freq[bestpos]+=beta;bias[bestpos]-=betagamma;return bestbiaspos}function inxbuild(){var i,j,p,q,smallpos,smallval,previouscol=0,startpos=0;for(i=0;i<netsize;i++){p=network[i];smallpos=i;smallval=p[1];for(j=i+1;j<netsize;j++){q=network[j];if(q[1]<smallval){smallpos=j;smallval=q[1]}}q=network[smallpos];if(i!=smallpos){j=q[0];q[0]=p[0];p[0]=j;j=q[1];q[1]=p[1];p[1]=j;j=q[2];q[2]=p[2];p[2]=j;j=q[3];q[3]=p[3];p[3]=j}if(smallval!=previouscol){netindex[previouscol]=startpos+i>>1;for(j=previouscol+1;j<smallval;j++)netindex[j]=i;previouscol=smallval;startpos=i}}netindex[previouscol]=startpos+maxnetpos>>1;for(j=previouscol+1;j<256;j++)netindex[j]=maxnetpos}function inxsearch(b,g,r){var a,p,dist;var bestd=1e3;var best=-1;var i=netindex[g];var j=i-1;while(i<netsize||j>=0){if(i<netsize){p=network[i];dist=p[1]-g;if(dist>=bestd)i=netsize;else{i++;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}if(j>=0){p=network[j];dist=g-p[1];if(dist>=bestd)j=-1;else{j--;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}}return best}function learn(){var i;var lengthcount=pixels.length;var alphadec=30+(samplefac-1)/3;var samplepixels=lengthcount/(3*samplefac);var delta=~~(samplepixels/ncycles);var alpha=initalpha;var radius=initradius;var rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(i=0;i<rad;i++)radpower[i]=alpha*((rad*rad-i*i)*radbias/(rad*rad));var step;if(lengthcount<minpicturebytes){samplefac=1;step=3}else if(lengthcount%prime1!==0){step=3*prime1}else if(lengthcount%prime2!==0){step=3*prime2}else if(lengthcount%prime3!==0){step=3*prime3}else{step=3*prime4}var b,g,r,j;var pix=0;i=0;while(i<samplepixels){b=(pixels[pix]&255)<<netbiasshift;g=(pixels[pix+1]&255)<<netbiasshift;r=(pixels[pix+2]&255)<<netbiasshift;j=contest(b,g,r);altersingle(alpha,j,b,g,r);if(rad!==0)alterneigh(rad,j,b,g,r);pix+=step;if(pix>=lengthcount)pix-=lengthcount;i++;if(delta===0)delta=1;if(i%delta===0){alpha-=alpha/alphadec;radius-=radius/radiusdec;rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(j=0;j<rad;j++)radpower[j]=alpha*((rad*rad-j*j)*radbias/(rad*rad))}}}function buildColormap(){init();learn();unbiasnet();inxbuild()}this.buildColormap=buildColormap;function getColormap(){var map=[];var index=[];for(var i=0;i<netsize;i++)index[network[i][3]]=i;var k=0;for(var l=0;l<netsize;l++){var j=index[l];map[k++]=network[j][0];map[k++]=network[j][1];map[k++]=network[j][2]}return map}this.getColormap=getColormap;this.lookupRGB=inxsearch}module.exports=NeuQuant},{}],4:[function(require,module,exports){var GIFEncoder,renderFrame;GIFEncoder=require("./GIFEncoder.js");renderFrame=function(frame){var encoder,page,stream,transfer;encoder=new GIFEncoder(frame.width,frame.height);if(frame.index===0){encoder.writeHeader()}else{encoder.firstFrame=false}encoder.setTransparent(frame.transparent);encoder.setRepeat(frame.repeat);encoder.setDelay(frame.delay);encoder.setQuality(frame.quality);encoder.setDither(frame.dither);encoder.setGlobalPalette(frame.globalPalette);encoder.addFrame(frame.data);if(frame.last){encoder.finish()}if(frame.globalPalette===true){frame.globalPalette=encoder.getGlobalPalette()}stream=encoder.stream();frame.data=stream.pages;frame.cursor=stream.cursor;frame.pageSize=stream.constructor.pageSize;if(frame.canTransfer){transfer=function(){var i,len,ref,results;ref=frame.data;results=[];for(i=0,len=ref.length;i<len;i++){page=ref[i];results.push(page.buffer)}return results}();return self.postMessage(frame,transfer)}else{return self.postMessage(frame)}};self.onmessage=function(event){return renderFrame(event.data)}},{"./GIFEncoder.js":1}]},{},[4]);
//# sourceMappingURL=gif.worker.js.map
</script>

</body>
</html>